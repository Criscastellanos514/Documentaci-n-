{
  "ConnectionStrings": {
    "Default": "Server=TU_SERVIDOR;Database=control_inventario_ti;User Id=TU_USER;Password=TU_PASSWORD;TrustServerCertificate=True;"
  }
}



using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace RequestApprovalWorker.Data;

public class SqlConnectionFactory
{
    private readonly string _connStr;

    public SqlConnectionFactory(IConfiguration config)
    {
        _connStr = config.GetConnectionString("Default")
                  ?? throw new Exception("No existe ConnectionStrings:Default en appsettings.json");
    }

    public SqlConnection Create() => new SqlConnection(_connStr);
}



using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using RequestApprovalWorker.Data;
using RequestApprovalWorker.Services;
using Dapper;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((context, config) =>
    {
        config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
    })
    .ConfigureServices(services =>
    {
        services.AddSingleton<SqlConnectionFactory>();
        services.AddSingleton<RequestApprovalService>();
    })
    .Build();

using var scope = host.Services.CreateScope();
var approvalService = scope.ServiceProvider.GetRequiredService<RequestApprovalService>();
var factory = scope.ServiceProvider.GetRequiredService<SqlConnectionFactory>();

// 1) Tomar un request "Pendiente" (de tu DB)
using (var conn = factory.Create())
{
    await conn.OpenAsync();

    // OJO: esto asume que request_state_description = 'Pendiente'
    // Si tu campo usa otra cosa, me lo decís y lo ajusto.
    var req = await conn.QueryFirstOrDefaultAsync<(Guid request_id, Guid user_id)>(@"
SELECT TOP 1 request_id, user_id
FROM requests
WHERE request_state_description = 'Pendiente'
ORDER BY create_at DESC
");

    if (req.request_id == Guid.Empty)
    {
        Console.WriteLine("No encontré requests con request_state_description = 'Pendiente'.");
        return;
    }

    Console.WriteLine($"Probando con Request: {req.request_id} | User: {req.user_id}");

    // 2) Insertar approval automático para ese request
    await approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);
}

Console.WriteLine("Listo. Presiona ENTER para salir.");
Console.ReadLine();


using System.Data;
using System.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace RequestApprovalWorker.Data;

public class SqlConnectionFactory
{
    private readonly IConfiguration _config;

    public SqlConnectionFactory(IConfiguration config)
    {
        _config = config;
    }

    public IDbConnection Create()
    {
        var cs = _config.GetConnectionString("DefaultConnection");
        return new SqlConnection(cs);
    }
}


using Dapper;
using System.Data;
using RequestApprovalWorker.Data;

namespace RequestApprovalWorker.Services;

public class RequestApprovalService
{
    private readonly SqlConnectionFactory _factory;

    public RequestApprovalService(SqlConnectionFactory factory)
    {
        _factory = factory;
    }

    public async Task InsertApprovalForRequestAsync(Guid requestId, Guid userId)
    {
        using var conn = _factory.Create();
        conn.Open();

        // 1) entity_id de 'Request Approval'
        var entityId = await conn.QueryFirstAsync<Guid>(@"
SELECT TOP 1 entity_id
FROM entities
WHERE entity_name = 'Request Approval'");

        // 2) state_id de 'Pendiente'
        var stateId = await conn.QueryFirstAsync<Guid>(@"
SELECT TOP 1 state_id
FROM states
WHERE state_name = 'Pendiente'");

        // 3) state_entity_id (Pendiente + Request Approval)
        var stateEntityId = await conn.QueryFirstAsync<Guid>(@"
SELECT TOP 1 state_entity_id
FROM state_entities
WHERE entity_id = @entityId AND state_id = @stateId",
            new { entityId, stateId });

        // 4) Insert en request_approvals
        await conn.ExecuteAsync(@"
INSERT INTO request_approvals
(
    request_approval_id,
    request_id,
    user_id,
    state_entity_id,
    request_approval_type,
    approval_date,
    create_at,
    modify_at
)
VALUES
(
    NEWID(),
    @requestId,
    @userId,
    @stateEntityId,
    'AUTO',
    GETDATE(),
    GETDATE(),
    GETDATE()
)",
        new { requestId, userId, stateEntityId });
    }
}


using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using RequestApprovalWorker.Data;
using RequestApprovalWorker.Services;
using Dapper;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((context, config) =>
    {
        config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
    })
    .ConfigureServices(services =>
    {
        services.AddSingleton<SqlConnectionFactory>();
        services.AddSingleton<RequestApprovalService>();
    })
    .Build();

using var scope = host.Services.CreateScope();
var approvalService = scope.ServiceProvider.GetRequiredService<RequestApprovalService>();
var factory = scope.ServiceProvider.GetRequiredService<SqlConnectionFactory>();

using (var conn = factory.Create())
{
    conn.Open();

    // Busca el último request que esté en “Pendiente”
    // (si tu columna se llama diferente, ajustamos aquí)
    var req = await conn.QueryFirstOrDefaultAsync<(Guid request_id, Guid user_id)>(@"
SELECT TOP 1 request_id, user_id
FROM requests
WHERE request_state_description = 'Pendiente'
ORDER BY create_at DESC");

    if (req.request_id == Guid.Empty)
    {
        Console.WriteLine("No encontré requests en estado 'Pendiente'.");
        return;
    }

    Console.WriteLine($"Probando con Request: {req.request_id} | User: {req.user_id}");

    await approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);

    Console.WriteLine("✅ Approval automático insertado en request_approvals.");
}

Console.WriteLine("Listo.");

dotnet add package Dapper
dotnet add package Microsoft.Data.SqlClient


using System;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using RequestApprovalWorker.Data;
using RequestApprovalWorker.Services;

namespace RequestApprovalWorker
{
    internal class Program
    {
        public static async Task Main(string[] args)
        {
            var host = Host.CreateDefaultBuilder(args)
                .ConfigureAppConfiguration((context, config) =>
                {
                    config.AddJsonFile("Config/appsettings.json", optional: false, reloadOnChange: true);
                })
                .ConfigureServices(services =>
                {
                    services.AddSingleton<SqlConnectionFactory>();
                    services.AddSingleton<RequestApprovalService>();
                })
                .Build();

            using var scope = host.Services.CreateScope();
            var approvalService = scope.ServiceProvider.GetRequiredService<RequestApprovalService>();
            var factory = scope.ServiceProvider.GetRequiredService<SqlConnectionFactory>();

            using var conn = factory.Create();
            conn.Open();

            // Busca el último request que esté en "Pendiente"
            // Si tu columna se llama distinto, cámbiala aquí:
            var req = await conn.QueryFirstOrDefaultAsync<(Guid request_id, Guid user_id)>(@"
                SELECT TOP 1 request_id, user_id
                FROM requests
                WHERE request_state_description = 'Pendiente'
                ORDER BY create_at DESC
            ");

            if (req.request_id == Guid.Empty)
            {
                Console.WriteLine("No encontré requests en estado 'Pendiente'.");
                return;
            }

            Console.WriteLine($"Probando con Request: {req.request_id} | User: {req.user_id}");

            await approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);

            Console.WriteLine("✅ Approval automático insertado en request_approvals.");
            Console.WriteLine("Listo.");
        }
    }
}

"DefaultConnection": "Server=localhost;Database=TU_DB;Trusted_Connection=True;TrustServerCertificate=True;"


{
  "ConnectionStrings": {
    "Default": "Server=localhost;Database=TU_BASE_DE_DATOS;Trusted_Connection=True;TrustServerCertificate=True;"
  },
  "Worker": {
    "IntervalSeconds": 10,
    "DryRun": false
  }
}


dotnet add package Dapper
dotnet add package Microsoft.Data.SqlClient
dotnet add package Microsoft.Extensions.Configuration.Json


"ConnectionStrings": {
  "Default": "Server=.;Database=TU_BASE_DE_DATOS;Trusted_Connection=True;TrustServerCertificate=True;"
}

"ConnectionStrings": {
  "Default": "Server=HNCSTG010240WAP\\HNCSTG010240WAP;Database=TU_BASE_DE_DATOS;Trusted_Connection=True;TrustServerCertificate=True;"
}

config.AddJsonFile("Config/appsettings.json", optional: false, reloadOnChange: true);




using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using PruebaWorker;
using PruebaWorker.Data;
using PruebaWorker.Services;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((context, services) =>
    {
        services.AddSingleton<SqlConnectionFactory>();
        services.AddSingleton<RequestApprovalService>();
        services.AddHostedService<Worker>();
    })
    .Build();

await host.RunAsync();

{
  "ConnectionStrings": {
    "Default": "Server=HNCSTG010240WAP\\HNCSTG010240WAP;Database=TU_BASE_DE_DATOS;Trusted_Connection=True;TrustServerCertificate=True;"
 o },
  "Worker": {
    "IntervalSeconds": 10,
    "DryRun": false
  }
}




"Broker": {
  "Url": "ws://localhost:5000/ws"
}



"Broker": {
  "Url": "ws://localhost:9991/ws"
}


{
  "ConnectionStrings": {
    "Default": "Server=localhost;Database=contro_inventario_ti;Trusted_Connection=True;TrustServerCertificate=True;Encrypt=False;"
  },
  "Worker": {
    "IntervalSeconds": 10,
    "DryRun": false,
    "BatchSize": 10
  },
  "Broker": {
    "Url": "ws://166.178.5.148:5000/ws",
    "Enabled": true
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}



using System.Net.WebSockets;
using System.Text;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace PruebaWorker.Services;

public interface IMessageBroker
{
    Task PublishAsync(string message, CancellationToken ct);
}

public class WebSocketMessageBroker : IMessageBroker
{
    private readonly ILogger<WebSocketMessageBroker> _logger;
    private readonly string _url;
    private readonly bool _enabled;

    public WebSocketMessageBroker(IConfiguration config, ILogger<WebSocketMessageBroker> logger)
    {
        _logger = logger;
        _url = config["Broker:Url"] ?? "";
        _enabled = bool.TryParse(config["Broker:Enabled"], out var en) && en;
    }

    public async Task PublishAsync(string message, CancellationToken ct)
    {
        if (!_enabled)
        {
            _logger.LogInformation("Broker deshabilitado. Mensaje no enviado: {Message}", message);
            return;
        }

        if (string.IsNullOrWhiteSpace(_url))
            throw new InvalidOperationException("Broker:Url no está configurado.");

        using var ws = new ClientWebSocket();
        _logger.LogInformation("Conectando al broker WS: {Url}", _url);

        await ws.ConnectAsync(new Uri(_url), ct);

        var bytes = Encoding.UTF8.GetBytes(message);
        await ws.SendAsync(bytes, WebSocketMessageType.Text, endOfMessage: true, cancellationToken: ct);

        _logger.LogInformation("Mensaje enviado al broker (len={Len}).", bytes.Length);

        await ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "ok", ct);
    }
}

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Configuration;
using PruebaWorker.Data;
using PruebaWorker.Services;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureAppConfiguration((context, config) =>
    {
        config.AddJsonFile("Config/appsettings.json", optional: false, reloadOnChange: true);
    })
    .ConfigureServices((context, services) =>
    {
        services.AddSingleton<SqlConnectionFactory>();
        services.AddSingleton<RequestApprovalService>();

        // Broker
        services.AddSingleton<IMessageBroker, WebSocketMessageBroker>();

        // Worker
        services.AddHostedService<Worker>();
    })
    .Build();

await host.RunAsync();






using System.Data;
using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using PruebaWorker.Data;
using PruebaWorker.Services;

namespace PruebaWorker;

public class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;
    private readonly IConfiguration _config;
    private readonly SqlConnectionFactory _factory;
    private readonly RequestApprovalService _approvalService;
    private readonly IMessageBroker _broker;

    public Worker(
        ILogger<Worker> logger,
        IConfiguration config,
        SqlConnectionFactory factory,
        RequestApprovalService approvalService,
        IMessageBroker broker)
    {
        _logger = logger;
        _config = config;
        _factory = factory;
        _approvalService = approvalService;
        _broker = broker;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var intervalSeconds = _config.GetValue<int>("Worker:IntervalSeconds", 10);
        var dryRun = _config.GetValue<bool>("Worker:DryRun", false);
        var batchSize = _config.GetValue<int>("Worker:BatchSize", 10);

        _logger.LogInformation("Worker iniciado. IntervalSeconds={IntervalSeconds}, DryRun={DryRun}, BatchSize={BatchSize}",
            intervalSeconds, dryRun, batchSize);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await ProcessBatchAsync(batchSize, dryRun, stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error en ejecución del worker.");
            }

            await Task.Delay(TimeSpan.FromSeconds(intervalSeconds), stoppingToken);
        }
    }

    private async Task ProcessBatchAsync(int batchSize, bool dryRun, CancellationToken ct)
    {
        using var conn = _factory.Create();
        conn.Open();

        // 1) Traer pendientes (ajusta el WHERE a tu esquema real)
        var pending = (await conn.QueryAsync<RequestRow>(@"
SELECT TOP (@batchSize)
    request_id,
    user_id
FROM requests
WHERE request_state_description = 'Pendiente'
ORDER BY create_at DESC;",
            new { batchSize }))
            .ToList();

        if (pending.Count == 0)
        {
            _logger.LogInformation("No encontré requests en estado Pendiente.");
            return;
        }

        _logger.LogInformation("Pendientes encontrados: {Count}", pending.Count);

        foreach (var req in pending)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();

            using var tx = conn.BeginTransaction();

            try
            {
                // 2) Marcar “EnProceso” para evitar doble-proceso (opcional pero recomendado)
                var updated = await conn.ExecuteAsync(@"
UPDATE requests
SET request_state_description = 'EnProceso'
WHERE request_id = @request_id AND request_state_description = 'Pendiente';",
                    new { req.request_id }, tx);

                if (updated == 0)
                {
                    _logger.LogWarning("Request {RequestId} ya no está Pendiente (probablemente otro proceso lo tomó).", req.request_id);
                    tx.Rollback();
                    continue;
                }

                _logger.LogInformation("Procesando RequestId={RequestId} UserId={UserId} DryRun={DryRun}",
                    req.request_id, req.user_id, dryRun);

                if (!dryRun)
                {
                    // 3) Tu lógica real (inserta approval, etc.)
                    await _approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);

                    // 4) Marcar Aprobada (ajusta)
                    await conn.ExecuteAsync(@"
UPDATE requests
SET request_state_description = 'Aprobada'
WHERE request_id = @request_id;",
                        new { req.request_id }, tx);

                    // 5) Publicar al broker (mensaje simple JSON)
                    var msg = $"{{\"type\":\"request.approved\",\"requestId\":\"{req.request_id}\",\"userId\":\"{req.user_id}\"}}";
                    await _broker.PublishAsync(msg, ct);
                }

                tx.Commit();
                sw.Stop();

                _logger.LogInformation("OK RequestId={RequestId} en {Ms}ms", req.request_id, sw.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                try
                {
                    // Marcar Error y guardar detalle mínimo (si tienes columna)
                    await conn.ExecuteAsync(@"
UPDATE requests
SET request_state_description = 'Error'
WHERE request_id = @request_id;",
                        new { req.request_id }, tx);

                    tx.Commit();
                }
                catch
                {
                    tx.Rollback();
                }

                _logger.LogError(ex, "FALLÓ RequestId={RequestId}", req.request_id);
            }
        }
    }

    private sealed record RequestRow(Guid request_id, Guid user_id);
}