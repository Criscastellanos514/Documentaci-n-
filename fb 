USE control_inventario_ti;
GO

SELECT state_id, state_name
FROM dbo.states
ORDER BY state_name;

SELECT TOP 1 entity_id
FROM dbo.entities
WHERE entity_name = 'Request Approval';

SELECT TOP 1 state_id
FROM dbo.states
WHERE state_name = 'Pendiente';

SELECT TOP 1 state_entity_id
FROM dbo.state_entities;


SELECT *
FROM request_approvals
WHERE request_id = (
    SELECT request_id
    FROM requests
    WHERE request_name = 'Prueba_worker_001'
);


SELECT 
  ra.request_approval_id,
  ra.request_id,
  ra.user_id,
  ra.state_entity_id,
  s.state_name,
  e.entity_name,
  ra.request_approval_type,
  ra.create_at,
  ra.modify_at
FROM dbo.request_approvals ra
JOIN dbo.state_entities se ON se.state_entity_id = ra.state_entity_id
JOIN dbo.states s ON s.state_id = se.state_id
JOIN dbo.entities e ON e.entity_id = se.entity_id
WHERE ra.request_id = (
  SELECT request_id
  FROM dbo.requests
  WHERE request_name = 'Prueba_worker_001'
);

SELECT TOP 1
  se.state_entity_id,
  s.state_name,
  e.entity_name
FROM dbo.state_entities se
JOIN dbo.states s ON s.state_id = se.state_id
JOIN dbo.entities e ON e.entity_id = se.entity_id
WHERE e.entity_name = 'Request Approval'
  AND s.state_name = 'Pendiente';



  USE control_inventario_ti;
GO

DECLARE @RequestName NVARCHAR(200) = 'Prueba_worker_001';
DECLARE @NewStateName NVARCHAR(100) = N'En revisiÃ³n';

DECLARE @RequestId UNIQUEIDENTIFIER;
DECLARE @EntityId UNIQUEIDENTIFIER;
DECLARE @StateId UNIQUEIDENTIFIER;
DECLARE @NewStateEntityId UNIQUEIDENTIFIER;

-- 1) RequestId
SELECT TOP 1 @RequestId = request_id
FROM dbo.requests
WHERE request_name = @RequestName;

-- 2) EntityId de "Request Approval"
SELECT TOP 1 @EntityId = entity_id
FROM dbo.entities
WHERE entity_name = 'Request Approval';

-- 3) StateId del nuevo estado
SELECT TOP 1 @StateId = state_id
FROM dbo.states
WHERE state_name = @NewStateName;

-- 4) StateEntityId (Entity + State)
SELECT TOP 1 @NewStateEntityId = state_entity_id
FROM dbo.state_entities
WHERE entity_id = @EntityId
  AND state_id  = @StateId;

-- Validaciones (por si algo no existe)
IF @RequestId IS NULL
BEGIN
    RAISERROR('No existe la request con ese nombre.', 16, 1);
    RETURN;
END

IF @EntityId IS NULL
BEGIN
    RAISERROR('No existe entity_name = Request Approval en dbo.entities.', 16, 1);
    RETURN;
END

IF @StateId IS NULL
BEGIN
    RAISERROR('No existe state_name = En revisiÃ³n en dbo.states.', 16, 1);
    RETURN;
END

IF @NewStateEntityId IS NULL
BEGIN
    RAISERROR('No existe la combinaciÃ³n (Request Approval + En revisiÃ³n) en dbo.state_entities.', 16, 1);
    RETURN;
END

-- Ver ANTES
SELECT 'ANTES' AS momento, ra.request_approval_id, ra.request_id, ra.user_id, ra.state_entity_id, ra.modify_at
FROM dbo.request_approvals ra
WHERE ra.request_id = @RequestId;

BEGIN TRAN;

    -- Actualizar request_approvals
    UPDATE dbo.request_approvals
    SET state_entity_id = @NewStateEntityId,
        modify_at = SYSUTCDATETIME()
    WHERE request_id = @RequestId;

    SELECT @@ROWCOUNT AS FilasAfectadas_request_approvals;

    -- (Opcional) reflejarlo en requests tambiÃ©n
    UPDATE dbo.requests
    SET request_state_description = @NewStateName
    WHERE request_id = @RequestId;

    SELECT @@ROWCOUNT AS FilasAfectadas_requests;

COMMIT;

-- Ver DESPUÃ‰S (con join para ver el nombre del estado)
SELECT
    'DESPUES' AS momento,
    ra.request_approval_id,
    ra.request_id,
    ra.user_id,
    ra.state_entity_id,
    s.state_name,
    e.entity_name,
    ra.modify_at
FROM dbo.request_approvals ra
JOIN dbo.state_entities se ON se.state_entity_id = ra.state_entity_id
JOIN dbo.states s ON s.state_id = se.state_id
JOIN dbo.entities e ON e.entity_id = se.entity_id
WHERE ra.request_id = @RequestId;p


SELECT
    r.request_name,
    s.state_name
FROM dbo.requests r
JOIN dbo.request_approvals ra ON ra.request_id = r.request_id
JOIN dbo.state_entities se ON se.state_entity_id = ra.state_entity_id
JOIN dbo.states s ON s.state_id = se.state_id
WHERE r.request_name = 'Prueba_worker_001';


SELECT r.request_name, s.state_name
FROM dbo.requests r
JOIN dbo.request_approvals ra ON ra.request_id = r.request_id
JOIN dbo.state_entities se ON se.state_entity_id = ra.state_entity_id
JOIN dbo.states s ON s.state_id = se.state_id
WHERE r.request_name = 'NombreQueCreaste';


public async Task<int> UpdatePendingToReviewIfCompleteAsync(Guid requestId, CancellationToken ct = default)
{
    // 1) Cargar estado actual y revisor desde request_approvals
    var data = await _db.QueryFirstOrDefaultAsync<(Guid StateEntityId, Guid? ReviewerUserId)>(
        @"SELECT TOP 1 state_entity_id, reviewer_user_id  -- <-- AJUSTA SI ES OTRO NOMBRE
          FROM dbo.request_approvals
          WHERE request_id = @requestId
          ORDER BY modify_at DESC;",
        new { requestId });

    if (data == default)
        return 0;

    // 2) Resolver entity + states
    var entityId = await _db.ExecuteScalarAsync<Guid>(
        @"SELECT TOP 1 entity_id
          FROM dbo.entities
          WHERE entity_name = 'Request Approval';");

    var pending = await _db.ExecuteScalarAsync<Guid>(
        @"SELECT TOP 1 se.state_entity_id
          FROM dbo.state_entities se
          JOIN dbo.states s ON s.state_id = se.state_id
          WHERE se.entity_id = @entityId
            AND s.state_name = 'Pendiente';",
        new { entityId });

    var review = await _db.ExecuteScalarAsync<Guid>(
        @"SELECT TOP 1 se.state_entity_id
          FROM dbo.state_entities se
          JOIN dbo.states s ON s.state_id = se.state_id
          WHERE se.entity_id = @entityId
            AND s.state_name = N'En revisiÃ³n';",
        new { entityId });

    // 3) Si no estÃ¡ pendiente, no hacer nada
    if (data.StateEntityId != pending)
        return 0;

    // 4) Si no tiene revisor, se queda pendiente
    if (data.ReviewerUserId is null || data.ReviewerUserId == Guid.Empty)
        return 0;

    // 5) UPDATE idempotente (Pendiente â†’ En revisiÃ³n)
    var rows = await _db.ExecuteAsync(
        @"UPDATE dbo.request_approvals
          SET state_entity_id = @review,
              modify_at = SYSUTCDATETIME()
          WHERE request_id = @requestId
            AND state_entity_id = @pending;",
        new { requestId, pending, review });

    // (Opcional) sincronizar requests si tu UI usa ese campo
    await _db.ExecuteAsync(
        @"UPDATE dbo.requests
          SET request_state_description = N'En revisiÃ³n'
          WHERE request_id = @requestId
            AND (request_state_description IS NULL OR request_state_description = N'Pendiente');",
        new { requestId });

    return rows;
}



using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using PruebaWorker;
using PruebaWorker.Data;
using PruebaWorker.Services;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices((context, services) =>
    {
        // ðŸ”¹ Factory de conexiÃ³n
        services.AddSingleton<SqlConnectionFactory>();

        // ðŸ”¹ Servicio de aprobaciones
        services.AddScoped<RequestApprovalService>();

        // ðŸ”¹ Worker principal
        services.AddHostedService<Worker>();
    })
    .Build();

await host.RunAsync();




using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

// ðŸ‘‡ Ajusta estos using segÃºn tus namespaces reales (por tus fotos, asÃ­ estÃ¡n)
using PruebaWorker.Data;
using PruebaWorker.Services;

namespace PruebaWorker;

public static class Program
{
    public static async Task Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.ClearProviders();
                logging.AddSimpleConsole(o =>
                {
                    o.SingleLine = true;
                    o.TimestampFormat = "HH:mm:ss ";
                });
                logging.SetMinimumLevel(LogLevel.Information);
            })
            .ConfigureServices((context, services) =>
            {
                // 1) ValidaciÃ³n rÃ¡pida de Connection String (para fallar temprano y claro)
                ValidateConfiguration(context.Configuration);

                // 2) InyecciÃ³n de dependencias base
                services.AddSingleton<SqlConnectionFactory>();

                // 3) Servicio de aprobaciones (tu clase real)
                services.AddScoped<RequestApprovalService>();

                // 4) Broker:
                //    - Si todavÃ­a NO tienes un broker real, este NoOp evita errores de DI.
                //    - Cuando tengas el broker real, reemplaza esta lÃ­nea por tu implementaciÃ³n.
                services.AddSingleton<IMessageBroker, NoOpMessageBroker>();

                // 5) Worker (BackgroundService)
                services.AddHostedService<Worker>();
            })
            .Build();

        await host.RunAsync();
    }

    private static void ValidateConfiguration(IConfiguration config)
    {
        var cs = config.GetConnectionString("Default");
        if (string.IsNullOrWhiteSpace(cs))
        {
            throw new InvalidOperationException(
                "Falta ConnectionStrings:Default en appsettings.json. " +
                "Ejemplo:\n" +
                "\"ConnectionStrings\": { \"Default\": \"Server=...;Database=...;User Id=...;Password=...;TrustServerCertificate=True;\" }"
            );
        }

        // Validaciones opcionales (por defecto si no existen)
        _ = config.GetValue<int?>("Worker:IntervalSeconds");
        _ = config.GetValue<bool?>("Worker:DryRun");
        _ = config.GetValue<int?>("Worker:BatchSize");
    }
}


// =====================================================
// âœ… Broker mÃ­nimo para que el Worker NO falle por DI
// =====================================================
public interface IMessageBroker
{
    Task PublishAsync(string message, CancellationToken ct = default);
}

public sealed class NoOpMessageBroker : IMessageBroker
{
    private readonly ILogger<NoOpMessageBroker> _logger;

    public NoOpMessageBroker(ILogger<NoOpMessageBroker> logger)
    {
        _logger = logger;
    }

    public Task PublishAsync(string message, CancellationToken ct = default)
    {
        // Solo loguea; NO envÃ­a nada.
        _logger.LogInformation("[BROKER:NOOP] Mensaje (simulado): {Message}", message);
        return Task.CompletedTask;
    }
}


SELECT *
FROM requests r
JOIN state_entities se ON r.state_entity_id = se.state_entity_id
JOIN states s ON se.state_id = s.state_id
WHERE s.state_name = 'Pendiente'


using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using PruebaWorker.Data;
using PruebaWorker.Services;

namespace PruebaWorker;

public static class Program
{
    public static async Task Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.ClearProviders();
                logging.AddSimpleConsole(o =>
                {
                    o.SingleLine = true;
                    o.TimestampFormat = "HH:mm:ss ";
                });
                logging.SetMinimumLevel(LogLevel.Information);
            })
            .ConfigureServices((context, services) =>
            {
                var configuration = context.Configuration;

                // ðŸ”¹ SQL Factory (Singleton)
                services.AddSingleton<SqlConnectionFactory>(sp =>
                    new SqlConnectionFactory(
                        configuration.GetConnectionString("DefaultConnection")
                    )
                );

                // ðŸ”¹ ESTE DEBE SER SCOPED
                services.AddScoped<RequestApprovalService>();

                // ðŸ”¹ Worker
                services.AddHostedService<Worker>();
            })
            .Build();

        await host.RunAsync();
    }
}
