dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.Configuration.Json
dotnet add package Microsoft.Extensions.Http
dotnet add package Microsoft.Data.SqlClient
dotnet add package Dapper

{
  "ConnectionStrings": {
    "Default": "Server=localhost;Database=ApprovalDB;User Id=sa;Password=YourPassword123;TrustServerCertificate=True;"
  },
  "Worker": {
    "IntervalSeconds": 30,
    "DryRun": false,
    "BatchSize": 10
  },
  "Broker": {
    "Url": "http://localhost:5050",
    "Topic": "request_approval"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}


namespace ApprovalWorker.Messaging;

public class ApprovalMessage
{
    public Guid RequestId { get; set; }
    public string Description { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public Guid UserId { get; set; }
    public DateTime Timestamp { get; set; }
}



namespace ApprovalWorker.Messaging;

public interface IMessageBroker
{
    Task SubscribeAsync(string topic, Func<ApprovalMessage, Task> handler, CancellationToken cancellationToken);
    Task PublishAsync(string topic, ApprovalMessage message, CancellationToken cancellationToken);
}


using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace ApprovalWorker.Messaging;

public class HttpPollingBroker : IMessageBroker
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<HttpPollingBroker> _logger;
    private readonly string _baseUrl;
    private readonly TimeSpan _pollingInterval = TimeSpan.FromSeconds(5);

    private static readonly JsonSerializerOptions _jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true
    };

    public HttpPollingBroker(HttpClient httpClient, IConfiguration configuration, ILogger<HttpPollingBroker> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["Broker:Url"] ?? throw new InvalidOperationException("Broker:Url no configurado.");
    }

    // ─── SUBSCRIBE ────────────────────────────────────────────────────────────

    public async Task SubscribeAsync(string topic, Func<ApprovalMessage, Task> handler, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Suscrito al topic '{Topic}'. Polling cada {Interval}s.", topic, _pollingInterval.TotalSeconds);

        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                var messages = await PollMessagesAsync(topic, cancellationToken);

                foreach (var message in messages)
                {
                    _logger.LogInformation("Mensaje recibido del topic '{Topic}': RequestId={RequestId}", topic, message.RequestId);
                    await handler(message);
                }
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error durante el polling del topic '{Topic}'.", topic);
            }

            await Task.Delay(_pollingInterval, cancellationToken);
        }

        _logger.LogInformation("Suscripción al topic '{Topic}' finalizada.", topic);
    }

    // ─── PUBLISH ──────────────────────────────────────────────────────────────

    public async Task PublishAsync(string topic, ApprovalMessage message, CancellationToken cancellationToken)
    {
        var url = $"{_baseUrl}/topics/{topic}/messages";
        var json = JsonSerializer.Serialize(message);
        var content = new StringContent(json, Encoding.UTF8, "application/json");

        var response = await _httpClient.PostAsync(url, content, cancellationToken);

        if (response.IsSuccessStatusCode)
            _logger.LogInformation("Mensaje publicado en topic '{Topic}': RequestId={RequestId}", topic, message.RequestId);
        else
            _logger.LogWarning("Error al publicar en topic '{Topic}': {StatusCode}", topic, response.StatusCode);
    }

    // ─── PRIVATE ──────────────────────────────────────────────────────────────

    private async Task<List<ApprovalMessage>> PollMessagesAsync(string topic, CancellationToken cancellationToken)
    {
        var url = $"{_baseUrl}/topics/{topic}/messages";
        var response = await _httpClient.GetAsync(url, cancellationToken);

        if (!response.IsSuccessStatusCode)
        {
            _logger.LogWarning("Polling sin respuesta exitosa: {StatusCode}", response.StatusCode);
            return [];
        }

        var json = await response.Content.ReadAsStringAsync(cancellationToken);

        if (string.IsNullOrWhiteSpace(json))
            return [];

        return JsonSerializer.Deserialize<List<ApprovalMessage>>(json, _jsonOptions) ?? [];
    }
}



using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace ApprovalWorker.Data;

public class SqlConnectionFactory
{
    private readonly string _connectionString;

    public SqlConnectionFactory(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("Default")
            ?? throw new InvalidOperationException("ConnectionString 'Default' no configurada.");
    }

    public SqlConnection CreateConnection()
    {
        return new SqlConnection(_connectionString);
    }
}


using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using ApprovalWorker.Data;

namespace ApprovalWorker.Services;

public class RequestApprovalService
{
    private readonly SqlConnectionFactory _connectionFactory;
    private readonly ILogger<RequestApprovalService> _logger;
    private readonly bool _dryRun;
    private readonly int _batchSize;

    public RequestApprovalService(
        SqlConnectionFactory connectionFactory,
        IConfiguration configuration,
        ILogger<RequestApprovalService> logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
        _dryRun = configuration.GetValue<bool>("Worker:DryRun");
        _batchSize = configuration.GetValue<int>("Worker:BatchSize", 10);
    }

    // ─── GET PENDIENTES ───────────────────────────────────────────────────────

    public async Task<IEnumerable<PendingRequest>> GetPendientesAsync()
    {
        const string sql = """
            SELECT TOP (@BatchSize)
                RequestId,
                UserId,
                Description,
                Name,
                Status,
                CreatedAt
            FROM Requests
            WHERE Status = 'Pending'
            ORDER BY CreatedAt ASC
            """;

        using var connection = _connectionFactory.CreateConnection();
        var results = await connection.QueryAsync<PendingRequest>(sql, new { BatchSize = _batchSize });

        _logger.LogInformation("Se encontraron {Count} requests pendientes.", results.Count());
        return results;
    }

    // ─── PROCESAR REQUEST ─────────────────────────────────────────────────────

    public async Task ProcesarRequestAsync(Guid requestId, Guid userId, string description)
    {
        _logger.LogInformation("Procesando RequestId={RequestId} UserId={UserId}", requestId, userId);

        if (_dryRun)
        {
            _logger.LogWarning("[DryRun] Se omite escritura en BD para RequestId={RequestId}", requestId);
            return;
        }

        const string insertSql = """
            IF NOT EXISTS (SELECT 1 FROM Requests WHERE RequestId = @RequestId)
            BEGIN
                INSERT INTO Requests (RequestId, UserId, Description, Status, CreatedAt)
                VALUES (@RequestId, @UserId, @Description, 'Pending', @CreatedAt)
            END
            """;

        using var connection = _connectionFactory.CreateConnection();

        await connection.ExecuteAsync(insertSql, new
        {
            RequestId  = requestId,
            UserId     = userId,
            Description = description,
            CreatedAt  = DateTime.UtcNow
        });

        _logger.LogInformation("RequestId={RequestId} guardado correctamente.", requestId);

        await MarcarEstadoAsync(requestId, "Processing");
    }

    // ─── MARCAR ESTADO ────────────────────────────────────────────────────────

    public async Task MarcarEstadoAsync(Guid requestId, string nuevoEstado)
    {
        if (_dryRun)
        {
            _logger.LogWarning("[DryRun] Se omite cambio de estado para RequestId={RequestId} → {Estado}", requestId, nuevoEstado);
            return;
        }

        const string sql = """
            UPDATE Requests
            SET Status = @Estado, UpdatedAt = @UpdatedAt
            WHERE RequestId = @RequestId
            """;

        using var connection = _connectionFactory.CreateConnection();

        await connection.ExecuteAsync(sql, new
        {
            RequestId  = requestId,
            Estado     = nuevoEstado,
            UpdatedAt  = DateTime.UtcNow
        });

        _logger.LogInformation("RequestId={RequestId} → Estado={Estado}", requestId, nuevoEstado);
    }
}

// ─── DTO INTERNO ──────────────────────────────────────────────────────────────

public class PendingRequest
{
    public Guid RequestId { get; set; }
    public Guid UserId { get; set; }
    public string Description { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
}


using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using ApprovalWorker.Messaging;
using ApprovalWorker.Services;

namespace ApprovalWorker;

public class Worker : BackgroundService
{
    private readonly IMessageBroker _broker;
    private readonly RequestApprovalService _approvalService;
    private readonly ILogger<Worker> _logger;
    private readonly string _topic;
    private readonly TimeSpan _interval;

    public Worker(
        IMessageBroker broker,
        RequestApprovalService approvalService,
        IConfiguration configuration,
        ILogger<Worker> logger)
    {
        _broker          = broker;
        _approvalService = approvalService;
        _logger          = logger;
        _topic           = configuration["Broker:Topic"]
                               ?? throw new InvalidOperationException("Broker:Topic no configurado.");
        _interval        = TimeSpan.FromSeconds(
                               configuration.GetValue<int>("Worker:IntervalSeconds", 30));
    }

    // ─── ENTRY POINT ──────────────────────────────────────────────────────────

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Worker iniciado. Topic='{Topic}' Intervalo={Interval}s",
            _topic, _interval.TotalSeconds);

        // Lanza la suscripción al topic en paralelo
        var subscriptionTask = SubscribeToTopicAsync(stoppingToken);

        // Polling de respaldo cada X segundos
        var pollingTask = RunPeriodicPollingAsync(stoppingToken);

        await Task.WhenAll(subscriptionTask, pollingTask);

        _logger.LogInformation("Worker detenido.");
    }

    // ─── SUSCRIPCIÓN AL TOPIC ─────────────────────────────────────────────────

    private async Task SubscribeToTopicAsync(CancellationToken stoppingToken)
    {
        try
        {
            await _broker.SubscribeAsync(_topic, HandleMessageAsync, stoppingToken);
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Suscripción al topic cancelada limpiamente.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fatal en la suscripción al topic '{Topic}'.", _topic);
        }
    }

    // ─── HANDLER DE MENSAJES ──────────────────────────────────────────────────

    private async Task HandleMessageAsync(ApprovalMessage message)
    {
        _logger.LogInformation(
            "Mensaje recibido — RequestId={RequestId} UserId={UserId} Timestamp={Timestamp}",
            message.RequestId, message.UserId, message.Timestamp);

        try
        {
            var description = string.IsNullOrWhiteSpace(message.Description)
                ? message.Name
                : message.Description;

            await _approvalService.ProcesarRequestAsync(
                message.RequestId,
                message.UserId,
                description);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error procesando RequestId={RequestId}.", message.RequestId);
        }
    }

    // ─── POLLING DE RESPALDO ──────────────────────────────────────────────────

    private async Task RunPeriodicPollingAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(_interval, stoppingToken);

                _logger.LogInformation("Revisión periódica iniciada.");

                var pendientes = await _approvalService.GetPendientesAsync();

                foreach (var request in pendientes)
                {
                    _logger.LogInformation(
                        "Procesando pendiente — RequestId={RequestId} UserId={UserId}",
                        request.RequestId, request.UserId);

                    await _approvalService.ProcesarRequestAsync(
                        request.RequestId,
                        request.UserId,
                        string.IsNullOrWhiteSpace(request.Description)
                            ? request.Name
                            : request.Description);
                }
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error durante la revisión periódica.");
            }
        }
    }
}
