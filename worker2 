dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.Configuration.Json
dotnet add package Microsoft.Extensions.Http
dotnet add package Microsoft.Data.SqlClient
dotnet add package Dapper

{
  "ConnectionStrings": {
    "Default": "Server=localhost;Database=ApprovalDB;User Id=sa;Password=YourPassword123;TrustServerCertificate=True;"
  },
  "Worker": {
    "IntervalSeconds": 30,
    "DryRun": false,
    "BatchSize": 10
  },
  "Broker": {
    "Url": "http://localhost:5050",
    "Topic": "request_approval"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}


namespace ApprovalWorker.Messaging;

public class ApprovalMessage
{
    public Guid RequestId { get; set; }
    public string Description { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public Guid UserId { get; set; }
    public DateTime Timestamp { get; set; }
}



namespace ApprovalWorker.Messaging;

public interface IMessageBroker
{
    Task SubscribeAsync(string topic, Func<ApprovalMessage, Task> handler, CancellationToken cancellationToken);
    Task PublishAsync(string topic, ApprovalMessage message, CancellationToken cancellationToken);
}


using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace ApprovalWorker.Messaging;

public class HttpPollingBroker : IMessageBroker
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<HttpPollingBroker> _logger;
    private readonly string _baseUrl;
    private readonly TimeSpan _pollingInterval = TimeSpan.FromSeconds(5);

    private static readonly JsonSerializerOptions _jsonOptions = new()
    {
        PropertyNameCaseInsensitive = true
    };

    public HttpPollingBroker(HttpClient httpClient, IConfiguration configuration, ILogger<HttpPollingBroker> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        _baseUrl = configuration["Broker:Url"] ?? throw new InvalidOperationException("Broker:Url no configurado.");
    }

    // ─── SUBSCRIBE ────────────────────────────────────────────────────────────

    public async Task SubscribeAsync(string topic, Func<ApprovalMessage, Task> handler, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Suscrito al topic '{Topic}'. Polling cada {Interval}s.", topic, _pollingInterval.TotalSeconds);

        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                var messages = await PollMessagesAsync(topic, cancellationToken);

                foreach (var message in messages)
                {
                    _logger.LogInformation("Mensaje recibido del topic '{Topic}': RequestId={RequestId}", topic, message.RequestId);
                    await handler(message);
                }
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error durante el polling del topic '{Topic}'.", topic);
            }

            await Task.Delay(_pollingInterval, cancellationToken);
        }

        _logger.LogInformation("Suscripción al topic '{Topic}' finalizada.", topic);
    }

    // ─── PUBLISH ──────────────────────────────────────────────────────────────

    public async Task PublishAsync(string topic, ApprovalMessage message, CancellationToken cancellationToken)
    {
        var url = $"{_baseUrl}/topics/{topic}/messages";
        var json = JsonSerializer.Serialize(message);
        var content = new StringContent(json, Encoding.UTF8, "application/json");

        var response = await _httpClient.PostAsync(url, content, cancellationToken);

        if (response.IsSuccessStatusCode)
            _logger.LogInformation("Mensaje publicado en topic '{Topic}': RequestId={RequestId}", topic, message.RequestId);
        else
            _logger.LogWarning("Error al publicar en topic '{Topic}': {StatusCode}", topic, response.StatusCode);
    }

    // ─── PRIVATE ──────────────────────────────────────────────────────────────

    private async Task<List<ApprovalMessage>> PollMessagesAsync(string topic, CancellationToken cancellationToken)
    {
        var url = $"{_baseUrl}/topics/{topic}/messages";
        var response = await _httpClient.GetAsync(url, cancellationToken);

        if (!response.IsSuccessStatusCode)
        {
            _logger.LogWarning("Polling sin respuesta exitosa: {StatusCode}", response.StatusCode);
            return [];
        }

        var json = await response.Content.ReadAsStringAsync(cancellationToken);

        if (string.IsNullOrWhiteSpace(json))
            return [];

        return JsonSerializer.Deserialize<List<ApprovalMessage>>(json, _jsonOptions) ?? [];
    }
}



using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace ApprovalWorker.Data;

public class SqlConnectionFactory
{
    private readonly string _connectionString;

    public SqlConnectionFactory(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("Default")
            ?? throw new InvalidOperationException("ConnectionString 'Default' no configurada.");
    }

    public SqlConnection CreateConnection()
    {
        return new SqlConnection(_connectionString);
    }
}


using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using ApprovalWorker.Data;

namespace ApprovalWorker.Services;

public class RequestApprovalService
{
    private readonly SqlConnectionFactory _connectionFactory;
    private readonly ILogger<RequestApprovalService> _logger;
    private readonly bool _dryRun;
    private readonly int _batchSize;

    public RequestApprovalService(
        SqlConnectionFactory connectionFactory,
        IConfiguration configuration,
        ILogger<RequestApprovalService> logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
        _dryRun = configuration.GetValue<bool>("Worker:DryRun");
        _batchSize = configuration.GetValue<int>("Worker:BatchSize", 10);
    }

    // ─── GET PENDIENTES ───────────────────────────────────────────────────────

    public async Task<IEnumerable<PendingRequest>> GetPendientesAsync()
    {
        const string sql = """
            SELECT TOP (@BatchSize)
                RequestId,
                UserId,
                Description,
                Name,
                Status,
                CreatedAt
            FROM Requests
            WHERE Status = 'Pending'
            ORDER BY CreatedAt ASC
            """;

        using var connection = _connectionFactory.CreateConnection();
        var results = await connection.QueryAsync<PendingRequest>(sql, new { BatchSize = _batchSize });

        _logger.LogInformation("Se encontraron {Count} requests pendientes.", results.Count());
        return results;
    }

    // ─── PROCESAR REQUEST ─────────────────────────────────────────────────────

    public async Task ProcesarRequestAsync(Guid requestId, Guid userId, string description)
    {
        _logger.LogInformation("Procesando RequestId={RequestId} UserId={UserId}", requestId, userId);

        if (_dryRun)
        {
            _logger.LogWarning("[DryRun] Se omite escritura en BD para RequestId={RequestId}", requestId);
            return;
        }

        const string insertSql = """
            IF NOT EXISTS (SELECT 1 FROM Requests WHERE RequestId = @RequestId)
            BEGIN
                INSERT INTO Requests (RequestId, UserId, Description, Status, CreatedAt)
                VALUES (@RequestId, @UserId, @Description, 'Pending', @CreatedAt)
            END
            """;

        using var connection = _connectionFactory.CreateConnection();

        await connection.ExecuteAsync(insertSql, new
        {
            RequestId  = requestId,
            UserId     = userId,
            Description = description,
            CreatedAt  = DateTime.UtcNow
        });

        _logger.LogInformation("RequestId={RequestId} guardado correctamente.", requestId);

        await MarcarEstadoAsync(requestId, "Processing");
    }

    // ─── MARCAR ESTADO ────────────────────────────────────────────────────────

    public async Task MarcarEstadoAsync(Guid requestId, string nuevoEstado)
    {
        if (_dryRun)
        {
            _logger.LogWarning("[DryRun] Se omite cambio de estado para RequestId={RequestId} → {Estado}", requestId, nuevoEstado);
            return;
        }

        const string sql = """
            UPDATE Requests
            SET Status = @Estado, UpdatedAt = @UpdatedAt
            WHERE RequestId = @RequestId
            """;

        using var connection = _connectionFactory.CreateConnection();

        await connection.ExecuteAsync(sql, new
        {
            RequestId  = requestId,
            Estado     = nuevoEstado,
            UpdatedAt  = DateTime.UtcNow
        });

        _logger.LogInformation("RequestId={RequestId} → Estado={Estado}", requestId, nuevoEstado);
    }
}

// ─── DTO INTERNO ──────────────────────────────────────────────────────────────

public class PendingRequest
{
    public Guid RequestId { get; set; }
    public Guid UserId { get; set; }
    public string Description { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
}
