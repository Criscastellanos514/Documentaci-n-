using System;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace ManageAdmin.GraphQL.Infrastructure.Background
{
    public class BackgroundTaskQueue : IBackgroundTaskQueue
    {
        private readonly Channel<Func<CancellationToken, Task>> _queue;

        public BackgroundTaskQueue()
        {
            _queue = Channel.CreateUnbounded<Func<CancellationToken, Task>>();
        }

        public void QueueBackgroundWorkItem(Func<CancellationToken, Task> workItem)
        {
            if (workItem == null)
                throw new ArgumentNullException(nameof(workItem));

            _queue.Writer.TryWrite(workItem);
        }

        public async Task<Func<CancellationToken, Task>> DequeueAsync(
            CancellationToken cancellationToken)
        {
            return await _queue.Reader.ReadAsync(cancellationToken);
        }
    }
}

using System;
using System.Threading;
using System.Threading.Tasks;

namespace ManageAdmin.GraphQL.Infrastructure.Background
{
    public interface IBackgroundTaskQueue
    {
        void QueueBackgroundWorkItem(Func<CancellationToken, Task> workItem);

        Task<Func<CancellationToken, Task>> DequeueAsync(
            CancellationToken cancellationToken);
    }
}


using System;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace ManageAdmin.GraphQL.Infrastructure.Background
{
    public class BackgroundTaskQueue : IBackgroundTaskQueue
    {
        private readonly Channel<Func<CancellationToken, Task>> _queue;

        public BackgroundTaskQueue()
        {
            _queue = Channel.CreateUnbounded<Func<CancellationToken, Task>>();
        }

        public void QueueBackgroundWorkItem(Func<CancellationToken, Task> workItem)
        {
            if (workItem == null)
                throw new ArgumentNullException(nameof(workItem));

            _queue.Writer.TryWrite(workItem);
        }

        public async Task<Func<CancellationToken, Task>> DequeueAsync(
            CancellationToken cancellationToken)
        {
            return await _queue.Reader.ReadAsync(cancellationToken);
        }
    }
}


using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ManageAdmin.GraphQL.Infrastructure.Background
{
    public class QueuedHostedService : BackgroundService
    {
        private readonly ILogger<QueuedHostedService> _logger;
        private readonly IBackgroundTaskQueue _taskQueue;
        private readonly IServiceScopeFactory _scopeFactory;

        public QueuedHostedService(
            IBackgroundTaskQueue taskQueue,
            IServiceScopeFactory scopeFactory,
            ILogger<QueuedHostedService> logger)
        {
            _taskQueue = taskQueue;
            _scopeFactory = scopeFactory;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("QueuedHostedService iniciado.");

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    // Espera hasta que haya un item en cola
                    var workItem = await _taskQueue.DequeueAsync(stoppingToken);

                    // Creamos un scope por tarea (IMPORTANTE para usar DB / Services sin romper DI)
                    using var scope = _scopeFactory.CreateScope();

                    // Ejecutamos la tarea
                    await workItem(stoppingToken);
                }
                catch (OperationCanceledException)
                {
                    // cierre normal
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error ejecutando tarea en background.");
                }
            }

            _logger.LogInformation("QueuedHostedService detenido.");
        }
    }
}

builder.Services.AddSingleton<IBackgroundTaskQueue, BackgroundTaskQueue>();
builder.Services.AddHostedService<QueuedHostedService>();

using ManageAdmin.GraphQL.Infrastructure.Background;private readonly DataBase dataBase;
private readonly RequestQueryBuilder queryBuilder;
private readonly IBackgroundTaskQueue taskQueue; iÃ³

public RequestServices(
    DataBase dataBase,
    RequestQueryBuilder queryBuilder,
    IBackgroundTaskQueue taskQueue)
{
    this.dataBase = dataBase;
    this.queryBuilder = queryBuilder;
    this.taskQueue = taskQueue;
}

var success = exec > 0;

if (success)
{
    taskQueue.QueueBackgroundWorkItem(async token =>
    {
        try
        {
            // SimulaciÃ³n de proceso largo
            await Task.Delay(2000, token);

            Console.WriteLine($"Procesando request {request.request_id}");

            // ðŸ”¥ AQUÃ puedes poner:
            // - Enviar correo
            // - Crear approval automÃ¡tico
            // - Generar tareas
            // - Validar reglas
            // - Llamar otro servicio
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error en background: {ex.Message}");
        }
    });
}

return success;

var success = exec > 0;

if (success)
{
    Console.WriteLine($"âœ… INSERT OK -> Encolando request {request.request_id}");

    taskQueue.QueueBackgroundWorkItem(async token =>
    {
        Console.WriteLine($"ðŸ”¥ BACKGROUND INICIADO -> request {request.request_id}");

        try
        {
            await Task.Delay(2000, token);
            Console.WriteLine($"âœ… Procesando request {request.request_id}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"âŒ Error en background: {ex.Message}");
        }
    });
}

return success;


if (success)
{
    taskQueue.QueueBackgroundWorkItem(async token =>
    {
        try
        {
            // 1) entity_id de "Request Approval"
            var entityId = await dataBase.Connection.QueryFirstAsync<Guid>(@"
                SELECT TOP 1 entity_id
                FROM entities
                WHERE entity_name = 'Request Approval'
            ");

            // 2) state_id de "Pendiente"
            var stateId = await dataBase.Connection.QueryFirstAsync<Guid>(@"
                SELECT TOP 1 state_id
                FROM states
                WHERE state_name = 'Pendiente'
            ");

            // 3) state_entity_id (Pendiente + Request Approval)
            var stateEntityId = await dataBase.Connection.QueryFirstAsync<Guid>(@"
                SELECT TOP 1 state_entity_id
                FROM state_entities
                WHERE entity_id = @entityId AND state_id = @stateId
            ", new { entityId, stateId });

            // 4) Insert automÃ¡tico en request_approvals
            await dataBase.Connection.ExecuteAsync(@"
                INSERT INTO request_approvals
                (
                    request_approval_id,
                    request_id,
                    user_id,
                    state_entity_id,
                    request_approval_type,
                    approval_date,
                    create_at,
                    modify_at
                )
                VALUES
                (
                    @request_approval_id,
                    @request_id,
                    @user_id,
                    @state_entity_id,
                    @request_approval_type,
                    @approval_date,
                    @create_at,
                    @modify_at
                )
            ",
            new
            {
                request_approval_id = Guid.NewGuid(),
                request_id = request.request_id,
                user_id = request.user_id,
                state_entity_id = stateEntityId,
                request_approval_type = "AUTO",
                approval_date = DateTime.UtcNow,
                create_at = DateTime.UtcNow,
                modify_at = DateTime.UtcNow
            });

            Console.WriteLine("âœ” AprobaciÃ³n automÃ¡tica creada (Pendiente)");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"âŒ Error en background approval: {ex.Message}");
        }
    });
}


namespace RequestApprovalWorker.Models;

public class RequestApproval
{
    public Guid request_approval_id { get; set; }
    public Guid request_id { get; set; }
    public Guid user_id { get; set; }
    public Guid state_entity_id { get; set; }
    public DateTime create_at { get; set; }
    public DateTime modify_at { get; set; }
    public string request_approval_type { get; set; } = "AUTOMATICO";
    public DateTime approval_date { get; set; } = DateTime.UtcNow;
}


using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace RequestApprovalWorker.Data;

public class SqlConnectionFactory
{
    private readonly string _connStr;

    public SqlConnectionFactory(IConfiguration config)
    {
        _connStr = config.GetConnectionString("Default") 
                   ?? throw new Exception("No existe ConnectionStrings:Default en appsettings.json");
    }

    public SqlConnection Create()
        => new SqlConnection(_connStr);
}


dotnet add package Dapper
dotnet add package Microsoft.Data.SqlClient
dotnet add package Microsoft.Extensions.Configuration.Json
dotnet add package Microsoft.Extensions.Hosting



using Dapper;
using RequestApprovalWorker.Data;

namespace RequestApprovalWorker.Services;

public class RequestApprovalService
{
    private readonly SqlConnectionFactory _factory;

    public RequestApprovalService(SqlConnectionFactory factory)
    {
        _factory = factory;
    }

    public async Task<int> InsertApprovalForRequestAsync(Guid requestId, Guid userId)
    {
        using var conn = _factory.Create();
        await conn.OpenAsync();

        // 1) entity_id de "Request Approval"
        var entityId = await conn.QueryFirstOrDefaultAsync<Guid?>(@"
SELECT TOP 1 entity_id
FROM entities
WHERE entity_name = 'Request Approval'");

        if (entityId is null)
        {
            Console.WriteLine("No existe entity_name = 'Request Approval' en entities.");
            return 0;
        }

        // 2) state_id de "Pendiente"
        var stateId = await conn.QueryFirstOrDefaultAsync<Guid?>(@"
SELECT TOP 1 state_id
FROM states
WHERE state_name = 'Pendiente'");

        if (stateId is null)
        {
            Console.WriteLine("No existe state_name = 'Pendiente' en states.");
            return 0;
        }

        // 3) state_entity_id (Pendiente + Request Approval)
        var stateEntityId = await conn.QueryFirstOrDefaultAsync<Guid?>(@"
SELECT TOP 1 state_entity_id
FROM state_entities
WHERE entity_id = @entityId AND state_id = @stateId",
            new { entityId, stateId });

        if (stateEntityId is null)
        {
            Console.WriteLine("No existe state_entity_id para (Request Approval + Pendiente).");
            return 0;
        }

        // 4) Evitar duplicar: si ya existe approval para ese request + state_entity_id
        var exists = await conn.QueryFirstOrDefaultAsync<int>(@"
SELECT COUNT(1)
FROM request_approvals
WHERE request_id = @requestId AND state_entity_id = @stateEntityId",
            new { requestId, stateEntityId });

        if (exists > 0)
        {
            Console.WriteLine($"Ya existe approval pendiente para request {requestId}. No inserto duplicado.");
            return 0;
        }

        // 5) Insert
        var rows = await conn.ExecuteAsync(@"
INSERT INTO request_approvals
(
    request_approval_id,
    request_id,
    user_id,
    state_entity_id,
    request_approval_type,
    approval_date,
    create_at,
    modify_at
)
VALUES
(
    NEWID(),
    @requestId,
    @userId,
    @stateEntityId,
    'AUTOMATICO',
    GETDATE(),
    GETDATE(),
    GETDATE()
)",
            new { requestId, userId, stateEntityId });

        Console.WriteLine($"âœ… Insertado approval automÃ¡tico. Rows: {rows} | Request: {requestId}");
        return rows;
    }
}

SELECT request_name, request_state_description
FROM control_inventario_ti.dbo.requests
WHERE request_state_description IS NULL
   OR request_state_description = '';



   using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using PruebaWorker.Data;
using PruebaWorker.Services;

namespace PruebaWorker;

public static class Program
{
    public static async Task Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.ClearProviders();
                logging.AddSimpleConsole(o =>
                {
                    o.SingleLine = true;
                    o.TimestampFormat = "HH:mm:ss ";
                });
                logging.SetMinimumLevel(LogLevel.Information);
            })
            .ConfigureServices((context, services) =>
            {
                // Factory DB
                services.AddSingleton<SqlConnectionFactory>();

                // Servicio principal
                services.AddSingleton<RequestApprovalService>();

                // Broker
                services.AddSingleton<IMessageBroker, WebSocketMessageBroker>();

                // Worker
                services.AddHostedService<Worker>();
            })
            .Build();

        await host.RunAsync();
    }
}