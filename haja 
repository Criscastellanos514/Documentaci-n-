{
  "ConnectionStrings": {
    "Default": "Server=TU_SERVIDOR;Database=TU_DB;User Id=TU_USER;Password=TU_PASS;TrustServerCertificate=True;"
  },
  "Worker": {
    "IntervalSeconds": 10,
    "DryRun": false
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}


using System.Data;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Configuration;

namespace PruebaWorker.Data
{
    public class SqlConnectionFactory
    {
        private readonly IConfiguration _config;

        public SqlConnectionFactory(IConfiguration config)
        {
            _config = config;
        }

        public IDbConnection Create()
        {
            var cs = _config.GetConnectionString("Default");

            if (string.IsNullOrWhiteSpace(cs))
                throw new InvalidOperationException("No se encontró ConnectionStrings:Default en appsettings.json");

            return new SqlConnection(cs);
        }
    }
}

using System;
using System.Threading.Tasks;
using Dapper;
using PruebaWorker.Data;

namespace PruebaWorker.Services
{
    public class RequestApprovalService
    {
        private readonly SqlConnectionFactory _factory;

        public RequestApprovalService(SqlConnectionFactory factory)
        {
            _factory = factory;
        }

        public async Task InsertApprovalForRequestAsync(Guid requestId, Guid userId)
        {
            using var conn = _factory.Create();
            conn.Open();

            // EJEMPLO: aquí va tu lógica real.
            // Te dejo un insert dummy para probar que Dapper + conexión funciona:
            await conn.ExecuteAsync(
                "INSERT INTO request_approvals (request_id, user_id, created_at) VALUES (@requestId, @userId, GETDATE())",
                new { requestId, userId }
            );
        }
    }
}


using System;
using System.Threading;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using PruebaWorker.Data;
using PruebaWorker.Services;

namespace PruebaWorker
{
    public class Worker : BackgroundService
    {
        private readonly ILogger<Worker> _logger;
        private readonly IConfiguration _config;
        private readonly SqlConnectionFactory _factory;
        private readonly RequestApprovalService _approvalService;

        public Worker(
            ILogger<Worker> logger,
            IConfiguration config,
            SqlConnectionFactory factory,
            RequestApprovalService approvalService)
        {
            _logger = logger;
            _config = config;
            _factory = factory;
            _approvalService = approvalService;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var seconds = _config.GetValue<int>("Worker:IntervalSeconds");
            var dryRun = _config.GetValue<bool>("Worker:DryRun");

            _logger.LogInformation("Worker iniciado. IntervalSeconds={seconds}, DryRun={dryRun}", seconds, dryRun);

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    using var conn = _factory.Create();
                    conn.Open();

                    // EJEMPLO: buscar 1 request pendiente (ajustá a tu tabla real)
                    var req = await conn.QueryFirstOrDefaultAsync<(Guid request_id, Guid user_id)>(@"
                        SELECT TOP 1 request_id, user_id
                        FROM requests
                        WHERE request_state_description = 'Pendiente'
                        ORDER BY create_at DESC
                    ");

                    if (req.request_id == Guid.Empty)
                    {
                        _logger.LogInformation("No encontré requests en estado Pendiente.");
                    }
                    else
                    {
                        _logger.LogInformation("Encontré request={request} user={user}", req.request_id, req.user_id);

                        if (!dryRun)
                        {
                            await _approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);
                            _logger.LogInformation("Approval insertado.");
                        }
                        else
                        {
                            _logger.LogInformation("DryRun=true: no inserté nada.");
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error en ejecución del worker");
                }

                await Task.Delay(TimeSpan.FromSeconds(seconds), stoppingToken);
            }
        }
    }
}


using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using PruebaWorker;
using PruebaWorker.Data;
using PruebaWorker.Services;

var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =>
    {
        services.AddSingleton<SqlConnectionFactory>();
        services.AddSingleton<RequestApprovalService>();
        services.AddHostedService<Worker>();
    })
    .Build();

await host.RunAsync();



SELECT TOP 50
    se.state_entity_id,
    e.entity_name,
    s.state_name,
    se.create_at,
    se.modify_at
FROM dbo.state_entities se
INNER JOIN dbo.entities e ON e.entity_id = se.entity_id
INNER JOIN dbo.states   s ON s.state_id   = se.state_id
WHERE e.entity_name IN ('Request', 'Requests', 'Request Approval', 'Solicitud')
  AND s.state_name IN ('Pendiente', 'Pending')
ORDER BY se.create_at DESC;




SELECT
    se.state_entity_id,
    e.entity_name,
    s.state_name
FROM dbo.state_entities se
INNER JOIN dbo.entities e ON e.entity_id = se.entity_id
INNER JOIN dbo.states   s ON s.state_id   = se.state_id
WHERE e.entity_name = 'Request'
  AND s.state_name  = 'Pendiente';  -- <-- aquí pon EXACTO el nombre que te salió


  SELECT TOP 50
    r.request_id,
    r.state_entity_id,
    e.entity_name,
    s.state_name,
    r.create_at
FROM dbo.requests r
INNER JOIN dbo.state_entities se ON se.state_entity_id = r.state_entity_id
INNER JOIN dbo.entities e ON e.entity_id = se.entity_id
INNER JOIN dbo.states s ON s.state_id = se.state_id
ORDER BY r.create_at DESC;

"Worker": {
  "PendingStateEntityId": "1701686C-649B-4560-BC69-D307D5E7F728",
  "RevisionStateEntityId": "F27EF7A8-793B-4237-AA99-20E39A51D785"
}

var pendingStateEntityId = _config.GetValue<Guid>("Worker:PendingStateEntityId");


var requests = await conn.QueryAsync<RequestDto>(
@"
SELECT TOP (@batchSize)
    request_id,
    request_name,
    request_description,
    state_entity_id,
    create_at
FROM dbo.requests
WHERE state_entity_id = @pendingStateEntityId
ORDER BY create_at ASC
",
new { batchSize, pendingStateEntityId });


var pendingStateId = Guid.Parse("1701686C-649B-4560-BC69-D307D5E7F728");

var pending = (await conn.QueryAsync<RequestRow>(@"
SELECT TOP (@batchSize)
    request_id,
    user_id,
    state_entity_id
FROM dbo.requests
WHERE state_entity_id = @pendingStateId
ORDER BY create_at DESC;",
new { batchSize, pendingStateId }))
.ToList();


var enProcesoStateId = Guid.Parse("F27EF7A8-793B-4237-AA99-20E39A51D785"); // <-- revisa el correcto

var updated = await conn.ExecuteAsync(@"
UPDATE requests
SET state_entity_id = @enProcesoStateId
WHERE request_id = @request_id
AND state_entity_id = @pendingStateId;",
new {
    request_id = req.request_id,
    enProcesoStateId,
    pendingStateId
}, tx);p





using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

namespace PruebaWorker
{
    public class Worker : BackgroundService
    {
        private readonly ILogger<Worker> _logger;
        private readonly SqlConnectionFactory _factory;
        private readonly IServiceScopeFactory _scopeFactory;

        private readonly int _intervalSeconds;
        private readonly bool _dryRun;

        // ✅ Ajusta estos GUID a los reales en tu BD
        private static readonly Guid PendingStateEntityId   = Guid.Parse("1701686C-649B-4560-BC69-D307D5E7F728"); // Pendiente (Request)
        private static readonly Guid InProcessStateEntityId  = Guid.Parse("F27EF7A8-793B-4237-AA99-20E39A51D785"); // En revisión / EnProceso (Request)

        public Worker(
            ILogger<Worker> logger,
            SqlConnectionFactory factory,
            IServiceScopeFactory scopeFactory,
            WorkerSettings settings)
        {
            _logger = logger;
            _factory = factory;
            _scopeFactory = scopeFactory;
            _intervalSeconds = settings.IntervalSeconds;
            _dryRun = settings.DryRun;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Worker iniciado. IntervalSeconds={Interval} DryRun={DryRun}",
                _intervalSeconds, _dryRun);

            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    await ProcessBatchAsync(batchSize: 10, stoppingToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error general del Worker.");
                }

                await Task.Delay(TimeSpan.FromSeconds(_intervalSeconds), stoppingToken);
            }
        }

        private async Task ProcessBatchAsync(int batchSize, CancellationToken ct)
        {
            using var conn = _factory.Create();
            conn.Open();

            // 1) Traer requests pendientes (por state_entity_id)
            var pending = (await conn.QueryAsync<RequestRow>(@"
                SELECT TOP (@batchSize)
                    request_id,
                    user_id,
                    state_entity_id
                FROM dbo.requests
                WHERE state_entity_id = @pendingState
                ORDER BY create_at DESC;",
                new { batchSize, pendingState = PendingStateEntityId }
            )).ToList();

            if (pending.Count == 0)
            {
                _logger.LogInformation("No encontré requests en estado Pendiente.");
                return;
            }

            _logger.LogInformation("Pendientes encontrados: {Count}", pending.Count);

            foreach (var req in pending)
            {
                if (ct.IsCancellationRequested) break;

                using var tx = conn.BeginTransaction();

                try
                {
                    // 2) Marcar como "EnProceso" con candado optimista
                    var updated = await conn.ExecuteAsync(@"
                        UPDATE dbo.requests
                        SET state_entity_id = @inProcess
                        WHERE request_id = @requestId
                          AND state_entity_id = @pending;",
                        new
                        {
                            requestId = req.request_id,
                            pending = PendingStateEntityId,
                            inProcess = InProcessStateEntityId
                        },
                        tx
                    );

                    if (updated == 0)
                    {
                        _logger.LogWarning("Request {RequestId} ya no está Pendiente (otro proceso lo tomó).", req.request_id);
                        tx.Rollback();
                        continue;
                    }

                    _logger.LogInformation("Procesando RequestId={RequestId} UserId={UserId} DryRun={DryRun}",
                        req.request_id, req.user_id, _dryRun);

                    if (!_dryRun)
                    {
                        // ✅ IMPORTANTE: Crear scope aquí (Worker es Singleton)
                        using var scope = _scopeFactory.CreateScope();
                        var approvalService = scope.ServiceProvider.GetRequiredService<RequestApprovalService>();

                        // 3) Tu lógica real: inserta approvals / crea tasks / etc.
                        await approvalService.InsertApprovalForRequestAsync(req.request_id, req.user_id);

                        // 4) (Opcional) Marcar como Aprobada / En revision según tu flujo
                        await conn.ExecuteAsync(@"
                            UPDATE dbo.requests
                            SET request_state_description = 'Aprobada'
                            WHERE request_id = @requestId;",
                            new { requestId = req.request_id }, tx);
                    }

                    tx.Commit();

                    _logger.LogInformation("OK RequestId={RequestId}", req.request_id);
                }
                catch (Exception ex)
                {
                    try
                    {
                        // (Opcional) marcar Error
                        await conn.ExecuteAsync(@"
                            UPDATE dbo.requests
                            SET request_state_description = 'Error'
                            WHERE request_id = @requestId;",
                            new { requestId = req.request_id }, tx);
                    }
                    catch { /* si falla no bloquea el rollback */ }

                    tx.Rollback();
                    _logger.LogError(ex, "Falló RequestId={RequestId}", req.request_id);
                }
            }
        }

        private sealed record RequestRow(Guid request_id, Guid user_id, Guid state_entity_id);
    }

    public sealed class WorkerSettings
    {
        public int IntervalSeconds { get; set; } = 10;
        public bool DryRun { get; set; } = false;
    }
}

using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace PruebaWorker
{
    public static class Program
    {
        public static async Task Main(string[] args)
        {
            var host = Host.CreateDefaultBuilder(args)
                .ConfigureLogging(logging =>
                {
                    logging.ClearProviders();
                    logging.AddSimpleConsole(o =>
                    {
                        o.SingleLine = true;
                        o.TimestampFormat = "HH:mm:ss ";
                    });
                    logging.SetMinimumLevel(LogLevel.Information);
                })
                .ConfigureServices((context, services) =>
                {
                    // Settings
                    var settings = new WorkerSettings();
                    context.Configuration.GetSection("Worker").Bind(settings);
                    services.AddSingleton(settings);

                    // DB Factory (normalmente Singleton)
                    services.AddSingleton<SqlConnectionFactory>();

                    // ✅ Service scoped (lo consumes con scope dentro del Worker)
                    services.AddScoped<RequestApprovalService>();

                    // Worker (HostedService) => Singleton
                    services.AddHostedService<Worker>();
                })
                .Build();

            await host.RunAsync();
        }
    }
}





using System;
using System.Threading.Tasks;
using Dapper;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;